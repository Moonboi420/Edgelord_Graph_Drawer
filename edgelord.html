<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Edgelord UI</title>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.5.2/dist/pixi.min.js"></script>
    <style>
        body { margin:0; overflow:hidden; background:#000; }
        canvas { display:block; }
    </style>
</head>
<body>
<script type="module">
(async () => {
    const app = new PIXI.Application();
    await app.init({
        resizeTo: window,
        background: 0x000000,
        antialias: true
    });
    document.body.appendChild(app.canvas);
    app.canvas.addEventListener('contextmenu', e => e.preventDefault());

    const edgeContainer = new PIXI.Container();
    app.stage.addChild(edgeContainer);

    let nodes = [];
    let edges = [];
    let draggingNode = null;
    let tempLine = null;
    let dbClickTimer = null;
    let longPressTimer = null;
    let longPressTarget = null;
    let instructionsVisible = false;
    let instructionsPanel = null;

    const textStyle = new PIXI.TextStyle({
        fill: 0xffa500,
        fontSize: 17
    });

    const colors = [0xffffff, 0xff3366, 0x00ff99, 0x4488ff, 0xffff66, 0xcc33ff, 0x00ffff, 0xffaa00];

    app.stage.eventMode = 'static';
    app.stage.hitArea = app.screen;
    app.stage.on('pointertap', onStageTap);

    // ? icon (top-left) – neon style
    const icon = new PIXI.Graphics()
        .circle(0, 0, 18)
        .fill({ color: 0x0a0a1f })
        .stroke({ width: 2.5, color: 0x00ffff });
    const iconText = new PIXI.Text({
        text: "?",
        style: new PIXI.TextStyle({ fill: 0x00ffff, fontSize: 26, fontWeight: '900' })
    });
    iconText.anchor.set(0.5);
    icon.addChild(iconText);
    icon.eventMode = 'static';
    icon.cursor = 'pointer';
    icon.position.set(24, 24);
    icon.on('pointertap', toggleInstructions);
    // subtle pulse
    app.ticker.add(() => {
        icon.scale.set(1 + Math.sin(app.ticker.lastTime * 0.004) * 0.06);
    });
    app.stage.addChild(icon);

    function toggleInstructions() {
        if (instructionsVisible) {
            if (instructionsPanel) {
                instructionsPanel.destroy();
                instructionsPanel = null;
            }
            instructionsVisible = false;
        } else {
            showInstructions();
            instructionsVisible = true;
        }
    }

    function showInstructions() {
        const panel = new PIXI.Container();

        // Background – glassmorphism + neon gradient using FillGradient
        const bg = new PIXI.Graphics();

        const gradient = new PIXI.FillGradient({
            type: 'linear',
            start: { x: 0, y: 0 },
            end: { x: 380, y: 210 },  // diagonal-ish
            colorStops: [
                { offset: 0, color: 0x1a0033 },
                { offset: 1, color: 0x001133 }
            ]
        });

        bg.rect(0, 0, 380, 210).fill(gradient);
        bg.roundRect(0, 0, 380, 240, 20).stroke({ width: 2.5, color: 0x00aaff, alpha: 0.7 });
        bg.roundRect(0, 0, 380, 240, 20).stroke({ width: 5, color: 0x00aaff, alpha: 0.15 }); // outer glow

        // inner shine overlay
        bg.rect(4, 4, 372, 232).fill({ color: 0xffffff, alpha: 0.07 });
        bg.roundRect(4, 4, 372, 232, 16); // just to clip nicely if needed

        panel.addChild(bg);

        // Title
        const title = new PIXI.Text({
            text: "INSTRUCTIONS",
            style: new PIXI.TextStyle({
                fill: 0x00ffff,
                fontSize: 22,
                fontWeight: '800',
                letterSpacing: 1.2,
                dropShadow: true,
                dropShadowColor: 0x00aaff,
                dropShadowBlur: 12,
                dropShadowDistance: 0
            })
        });
        title.position.set(30, 24);
        panel.addChild(title);

        // Instructions – updated text
        const instrText = `1) Double click to draw a node.
2) Click and drag to draw an edge.
3) Right click to delete an element.
4) Left click to change color.
5) Click and hold to label an edge.`;

        const instr = new PIXI.Text({
            text: instrText,
            style: new PIXI.TextStyle({
                fill: 0xe0f0ff,
                fontSize: 16,
                fontWeight: '500',
                lineHeight: 28,
                letterSpacing: 0.4,
                wordWrap: true,
                wordWrapWidth: 340,
                dropShadow: true,
                dropShadowColor: 0x004488,
                dropShadowBlur: 4,
                dropShadowDistance: 1.5
            })
        });
        instr.position.set(34, 68);
        panel.addChild(instr);

        // Close button – neon style
        const closeBtn = new PIXI.Container();
        const closeBg = new PIXI.Graphics()
            .circle(0, 0, 16)
            .fill({ color: 0x110022 })
            .stroke({ width: 2, color: 0xff3366 });

        const closeX = new PIXI.Text({
            text: "×",
            style: new PIXI.TextStyle({
                fill: 0xff6699,
                fontSize: 26,
                fontWeight: 'bold'
            })
        });
        closeX.anchor.set(0.5);
        closeBtn.addChild(closeBg, closeX);

        closeBtn.position.set(340, 28);
        closeBtn.eventMode = 'static';
        closeBtn.cursor = 'pointer';

        closeBtn.on('pointerover', () => {
            closeBg.clear()
                .circle(0, 0, 16)
                .fill({ color: 0x220044 })
                .stroke({ width: 2.5, color: 0xff6699 });
            closeX.style.fill = 0xff99bb;
        });
        closeBtn.on('pointerout', () => {
            closeBg.clear()
                .circle(0, 0, 16)
                .fill({ color: 0x110022 })
                .stroke({ width: 2, color: 0xff3366 });
            closeX.style.fill = 0xff6699;
        });
        closeBtn.on('pointertap', toggleInstructions);

        panel.addChild(closeBtn);

        // subtle entrance animation
        panel.alpha = 0;
        panel.scale.set(0.92);
        panel.position.set(40, 80);
        app.stage.addChild(panel);
        instructionsPanel = panel;

        let t = 0;
        const anim = () => {
            t += 0.055;
            if (t >= 1) {
                panel.alpha = 1;
                panel.scale.set(1);
                return;
            }
            panel.alpha = t;
            panel.scale.set(0.92 + t * 0.08);
            requestAnimationFrame(anim);
        };
        anim();
    }

    function onStageTap(e) {
        if (e.target !== app.stage) return;
        if (dbClickTimer) {
            clearTimeout(dbClickTimer);
            dbClickTimer = null;
            createNode(e.global);
        } else {
            dbClickTimer = setTimeout(() => { dbClickTimer = null; }, 250);
        }
    }

    function createNode(pos) {
        const name = getUnusedLetter();
        const graphic = new PIXI.Graphics()
            .circle(0, 0, 12)
            .fill({ color: 0xffffff });
        graphic.position.set(pos.x, pos.y);
        graphic.eventMode = 'static';
        graphic.cursor = 'pointer';
        graphic.on('pointerdown', onNodeDown);
        graphic.on('pointertap', onNodeTap);
        graphic.on('rightdown', e => { e.stopPropagation(); onNodeRight(e); });

        const label = new PIXI.Text({ text: name, style: textStyle });
        label.anchor.set(0.5);

        const paddingX = 7;
        const paddingY = 5;
        const bgWidth  = label.width  + paddingX * 2;
        const bgHeight = label.height + paddingY * 2;

        const bg = new PIXI.Graphics();
        bg.beginFill(0xffffff, 0.9);
        bg.drawRoundedRect(-bgWidth/2, -bgHeight/2, bgWidth, bgHeight, 8);
        bg.endFill();

        const labelContainer = new PIXI.Container();
        labelContainer.addChild(bg, label);
        label.position.set(0,0);
        labelContainer.position.set(pos.x + 16 + bgWidth/2, pos.y);

        app.stage.addChild(graphic, labelContainer);

        const node = { graphic, labelContainer, name, pos: {x:pos.x, y:pos.y}, colorIndex: 0 };
        nodes.push(node);
        graphic.nodeRef = node;
    }

    function getUnusedLetter() {
        const used = new Set(nodes.map(n => n.name));
        for (let i = 0; i < 26; i++) {
            const char = String.fromCharCode(65 + i);
            if (!used.has(char)) return char;
        }
        return String.fromCharCode(65 + (nodes.length % 26));
    }

    function onNodeTap(e) {
        e.stopPropagation();
        const node = e.target.nodeRef;
        node.colorIndex = (node.colorIndex + 1) % colors.length;
        updateNodeColor(node);
    }

    function updateNodeColor(node) {
        node.graphic.clear()
            .circle(0, 0, 12)
            .fill({ color: colors[node.colorIndex] });
    }

    function onNodeDown(e) {
        e.stopPropagation();
        draggingNode = e.target.nodeRef;
        tempLine = new PIXI.Graphics();
        app.stage.addChild(tempLine);

        app.canvas.addEventListener('pointermove', onDragMoveGlobal);
        app.canvas.addEventListener('pointerup', onDragEndGlobal);
        app.canvas.addEventListener('pointerupoutside', onDragEndGlobal);

        if (e.target.setPointerCapture) {
            e.target.setPointerCapture(e.pointerId);
        }
    }

    function onDragMoveGlobal(e) {
        if (!draggingNode || !tempLine) return;
        const rect = app.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        tempLine.clear()
            .moveTo(draggingNode.pos.x, draggingNode.pos.y)
            .lineTo(x, y)
            .stroke({ width: 3, color: 0xffffff });
    }

    function onDragEndGlobal(e) {
        app.canvas.removeEventListener('pointermove', onDragMoveGlobal);
        app.canvas.removeEventListener('pointerup', onDragEndGlobal);
        app.canvas.removeEventListener('pointerupoutside', onDragEndGlobal);

        if (tempLine) {
            tempLine.destroy();
            tempLine = null;
        }

        if (draggingNode) {
            const rect = app.canvas.getBoundingClientRect();
            const px = e.clientX - rect.left;
            const py = e.clientY - rect.top;

            let targetNode = null;
            for (let node of nodes) {
                if (node === draggingNode) continue;
                const dx = px - node.pos.x;
                const dy = py - node.pos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist <= 15) {
                    targetNode = node;
                    break;
                }
            }

            if (targetNode && !edgeExists(draggingNode, targetNode)) {
                createEdge(draggingNode, targetNode);
            }
        }

        draggingNode = null;
    }

    function edgeExists(a, b) {
        return edges.some(edge =>
            (edge.from === a && edge.to === b) || (edge.from === b && edge.to === a)
        );
    }

    function createEdge(from, to) {
        const graphic = new PIXI.Graphics();
        updateEdge(graphic, from.pos, to.pos, 0xffffff);
        graphic.eventMode = 'static';
        graphic.cursor = 'pointer';
        graphic.on('pointerdown', onEdgeDown);
        graphic.on('pointerup', onEdgeUp);
        graphic.on('pointertap', onEdgeTap);
        graphic.on('rightdown', e => { e.stopPropagation(); onEdgeRight(e); });
        edgeContainer.addChild(graphic);

        const edge = { graphic, from, to, colorIndex: 0, labelContainer: null, text: '' };
        edges.push(edge);
        graphic.edgeRef = edge;
    }

    function updateEdge(graphic, fromPos, toPos, color) {
        graphic.clear()
            .moveTo(fromPos.x, fromPos.y)
            .lineTo(toPos.x, toPos.y)
            .stroke({ width: 4, color });
    }

    function onEdgeTap(e) {
        e.stopPropagation();
        const edge = e.target.edgeRef;
        edge.colorIndex = (edge.colorIndex + 1) % colors.length;
        updateEdge(edge.graphic, edge.from.pos, edge.to.pos, colors[edge.colorIndex]);
        if (edge.labelContainer) updateEdgeLabelPosition(edge);
    }

    function onNodeRight(e) {
        const node = e.target.nodeRef;
        if (!node) return;
        
        edges = edges.filter(edge => {
            if (edge.from === node || edge.to === node) {
                if (edge.labelContainer) {
                    edge.labelContainer.destroy();
                    edge.labelContainer = null;
                }
                edge.graphic.destroy();
                return false;
            }
            return true;
        });
        
        node.graphic.destroy();
        node.labelContainer.destroy();
        nodes = nodes.filter(n => n !== node);
    }

    function onEdgeRight(e) {
        const edge = e.target.edgeRef;
        if (!edge) return;
        
        if (longPressTarget === edge) {
            clearTimeout(longPressTimer);
            longPressTarget = null;
        }
        
        if (edge.labelContainer) {
            edge.labelContainer.destroy();
            edge.labelContainer = null;
        }
        
        edge.graphic.destroy();
        edges = edges.filter(ed => ed !== edge);
    }

    function onEdgeDown(e) {
        if (e.button !== 0) return;
        
        e.stopPropagation();
        longPressTarget = e.target.edgeRef;
        longPressTimer = setTimeout(() => {
            if (longPressTarget) showEdgeLabelInput(longPressTarget, e.global);
        }, 500);
    }

    function onEdgeUp(e) {
        if (e.button !== 0) return;
        clearTimeout(longPressTimer);
        longPressTarget = null;
    }

    function showEdgeLabelInput(edge, pos) {
        const input = document.createElement('input');
        input.type = 'text';
        input.value = edge.text;
        input.style.position = 'absolute';
        input.style.left = `${pos.x}px`;
        input.style.top = `${pos.y}px`;
        input.style.zIndex = '1000';
        document.body.appendChild(input);
        input.focus();

        input.addEventListener('blur', () => {
            updateEdgeLabel(edge, input.value);
            document.body.removeChild(input);
        });

        input.addEventListener('keydown', (ev) => {
            if (ev.key === 'Enter') input.blur();
        });
    }

    function updateEdgeLabel(edge, text) {
        edge.text = text;
        if (edge.labelContainer) edge.labelContainer.destroy();

        if (!text) {
            edge.labelContainer = null;
            return;
        }

        const label = new PIXI.Text({ text, style: textStyle });
        label.anchor.set(0.5, 0.5);

        const paddingX = 6;
        const paddingY = 5;
        const bgWidth = label.width + paddingX * 2;
        const bgHeight = label.height + paddingY * 2;

        const bg = new PIXI.Graphics();
        bg.beginFill(0xffffff, 0.92);
        bg.drawRoundedRect(
            -bgWidth / 2,
            -bgHeight / 2,
            bgWidth,
            bgHeight,
            6
        );
        bg.endFill();

        const labelContainer = new PIXI.Container();
        labelContainer.addChild(bg);
        labelContainer.addChild(label);
        label.position.set(0, 0);

        updateEdgeLabelPosition(edge, labelContainer);
        app.stage.addChild(labelContainer);
        edge.labelContainer = labelContainer;
    }

    function updateEdgeLabelPosition(edge, container = edge.labelContainer) {
        if (!container) return;
        const midX = (edge.from.pos.x + edge.to.pos.x) / 2;
        const midY = (edge.from.pos.y + edge.to.pos.y) / 2;
        container.position.set(midX, midY);
    }

    window.addEventListener('resize', () => app.resize());
})();
</script>
</body>
</html>