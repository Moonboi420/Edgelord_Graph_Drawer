<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Edgelord UI</title>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.5.2/dist/pixi.min.js"></script>
    <style>
        body { margin:0; overflow:hidden; background:#000; }
        canvas { display:block; }
        #fileInput { display: none; }
    </style>
</head>
<body>
<input type="file" id="fileInput" accept=".json">

<script type="module">
(async () => {
    const app = new PIXI.Application();
    await app.init({
        resizeTo: window,
        background: 0x000000,
        antialias: true
    });
    document.body.appendChild(app.canvas);
    app.canvas.addEventListener('contextmenu', e => e.preventDefault());

    const edgeContainer = new PIXI.Container();
    app.stage.addChild(edgeContainer);

    let nodes = [];
    let edges = [];
    let draggingNode = null;
    let tempLine = null;
    let dbClickTimer = null;
    let longPressTimer = null;
    let longPressTarget = null;
    let instructionsVisible = false;
    let instructionsPanel = null;

    const textStyle = new PIXI.TextStyle({
        fill: 0xffa500,
        fontSize: 17
    });

    const colors = [0xffffff, 0xff3366, 0x00ff99, 0x4488ff, 0xffff66, 0xcc33ff, 0x00ffff, 0xffaa00];

    app.stage.eventMode = 'static';
    app.stage.hitArea = app.screen;
    app.stage.on('pointertap', onStageTap);

    const uiContainer = new PIXI.Container();
    uiContainer.position.set(10, 10);
    app.stage.addChild(uiContainer);

    const icon = new PIXI.Graphics()
        .circle(0, 0, 18)
        .fill({ color: 0x0a0a1f })
        .stroke({ width: 2.5, color: 0x00ffff });
    const iconText = new PIXI.Text({
        text: "?",
        style: new PIXI.TextStyle({ fill: 0x00ffff, fontSize: 26, fontWeight: '900' })
    });
    iconText.anchor.set(0.5);
    icon.addChild(iconText);
    icon.eventMode = 'static';
    icon.cursor = 'pointer';
    icon.position.set(24, 24);
    icon.on('pointertap', toggleInstructions);
    app.ticker.add(() => {
        icon.scale.set(1 + Math.sin(app.ticker.lastTime * 0.004) * 0.06);
    });
    uiContainer.addChild(icon);

    const exportBtn = createButton("Export JSON", 0x00ff99, 110, exportGraph);
    exportBtn.position.set(70, 10);
    uiContainer.addChild(exportBtn);

    const importBtn = createButton("Import JSON", 0x4488ff, 110, () => {
        document.getElementById('fileInput').click();
    });
    importBtn.position.set(190, 10);
    uiContainer.addChild(importBtn);

    const clearBtn = createButton("Clear", 0xff3366, 80, clearGraph);
    clearBtn.position.set(310, 10);
    uiContainer.addChild(clearBtn);

    document.getElementById('fileInput').addEventListener('change', handleFileImport);

    function createButton(text, color, width, onTap) {
        const btn = new PIXI.Container();
        const bg = new PIXI.Graphics()
            .roundRect(0, 0, width, 36, 8)
            .fill({ color })
            .stroke({ width: 1.5, color: 0xffffff, alpha: 0.4 });

        const txt = new PIXI.Text({
            text,
            style: new PIXI.TextStyle({
                fill: 0xffffff,
                fontSize: 15,
                fontWeight: 'bold'
            })
        });
        txt.anchor.set(0.5);
        txt.position.set(width/2, 18);

        btn.addChild(bg, txt);
        btn.eventMode = 'static';
        btn.cursor = 'pointer';
        btn.on('pointertap', onTap);
        return btn;
    }

    function toggleInstructions() {
        if (instructionsVisible) {
            if (instructionsPanel) {
                instructionsPanel.destroy();
                instructionsPanel = null;
            }
            instructionsVisible = false;
        } else {
            showInstructions();
            instructionsVisible = true;
        }
    }

    function showInstructions() {
        const panel = new PIXI.Container();

        const gradient = new PIXI.FillGradient({
            type: 'linear',
            start: { x: 0, y: 0 },
            end: { x: 380, y: 240 },
            colorStops: [
                { offset: 0, color: 0x1a0033 },
                { offset: 1, color: 0x001133 }
            ]
        });

        const bg = new PIXI.Graphics();
        bg.rect(0, 0, 380, 240).fill(gradient);
        bg.roundRect(0, 0, 380, 240, 20).stroke({ width: 2.5, color: 0x00aaff, alpha: 0.7 });
        bg.roundRect(0, 0, 380, 240, 20).stroke({ width: 5, color: 0x00aaff, alpha: 0.15 });
        bg.rect(4, 4, 372, 232).fill({ color: 0xffffff, alpha: 0.07 });
        bg.roundRect(4, 4, 372, 232, 16);

        panel.addChild(bg);

        const title = new PIXI.Text({
            text: "INSTRUCTIONS",
            style: new PIXI.TextStyle({
                fill: 0x00ffff,
                fontSize: 22,
                fontWeight: '800',
                letterSpacing: 1.2,
                dropShadow: true,
                dropShadowColor: 0x00aaff,
                dropShadowBlur: 12,
                dropShadowDistance: 0
            })
        });
        title.position.set(30, 24);
        panel.addChild(title);

        const instrText = `1) Double click to draw a node.\n2) Click and drag to draw an edge.\n3) Right click to delete an element.\n4) Click and hold to label an edge.`;

        const instr = new PIXI.Text({
            text: instrText,
            style: new PIXI.TextStyle({
                fill: 0xe0f0ff,
                fontSize: 16,
                fontWeight: '500',
                lineHeight: 28,
                letterSpacing: 0.4,
                wordWrap: true,
                wordWrapWidth: 340,
                dropShadow: true,
                dropShadowColor: 0x004488,
                dropShadowBlur: 4,
                dropShadowDistance: 1.5
            })
        });
        instr.position.set(34, 78);
        panel.addChild(instr);

        const closeBtn = new PIXI.Container();
        const closeBg = new PIXI.Graphics()
            .circle(0, 0, 16)
            .fill({ color: 0x110022 })
            .stroke({ width: 2, color: 0xff3366 });

        const closeX = new PIXI.Text({
            text: "Ã—",
            style: new PIXI.TextStyle({
                fill: 0xff6699,
                fontSize: 26,
                fontWeight: 'bold'
            })
        });
        closeX.anchor.set(0.5);
        closeBtn.addChild(closeBg, closeX);

        closeBtn.position.set(340, 28);
        closeBtn.eventMode = 'static';
        closeBtn.cursor = 'pointer';

        closeBtn.on('pointerover', () => {
            closeBg.clear()
                .circle(0, 0, 16)
                .fill({ color: 0x220044 })
                .stroke({ width: 2.5, color: 0xff6699 });
            closeX.style.fill = 0xff99bb;
        });
        closeBtn.on('pointerout', () => {
            closeBg.clear()
                .circle(0, 0, 16)
                .fill({ color: 0x110022 })
                .stroke({ width: 2, color: 0xff3366 });
            closeX.style.fill = 0xff6699;
        });
        closeBtn.on('pointertap', toggleInstructions);

        panel.addChild(closeBtn);

        panel.alpha = 0;
        panel.scale.set(0.92);
        panel.position.set(40, 80);
        app.stage.addChild(panel);
        instructionsPanel = panel;

        let t = 0;
        const anim = () => {
            t += 0.055;
            if (t >= 1) {
                panel.alpha = 1;
                panel.scale.set(1);
                return;
            }
            panel.alpha = t;
            panel.scale.set(0.92 + t * 0.08);
            requestAnimationFrame(anim);
        };
        anim();
    }

    function exportGraph() {
        const data = {
            nodes: nodes.map(n => ({
                name: n.name,
                x: n.pos.x,
                y: n.pos.y,
                colorIndex: n.colorIndex
            })),
            edges: edges.map(e => ({
                from: e.from.name,
                to: e.to.name,
                colorIndex: e.colorIndex,
                text: e.text || ""
            }))
        };

        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'graph.json';
        a.click();
        URL.revokeObjectURL(url);
    }

    function handleFileImport(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = JSON.parse(e.target.result);
                clearGraph();
                importGraph(data);
            } catch (err) {
                console.error("Invalid JSON", err);
                alert("Failed to parse file. Not a valid graph JSON.");
            }
        };
        reader.readAsText(file);

        event.target.value = '';
    }

    function importGraph(data) {
        const nodeMap = new Map();

        data.nodes.forEach(nodeData => {
            const pos = { x: nodeData.x, y: nodeData.y };
            createNode(pos);
            const node = nodes[nodes.length - 1];
            node.name = nodeData.name;
            node.colorIndex = nodeData.colorIndex ?? 0;
            updateNodeColor(node);
            const label = node.labelContainer.children[1];
            label.text = node.name;
            const bg = node.labelContainer.children[0];
            bg.clear();
            const tempLabel = new PIXI.Text({ text: node.name, style: textStyle });
            const paddingX = 7, paddingY = 5;
            const w = tempLabel.width + paddingX * 2;
            const h = tempLabel.height + paddingY * 2;
            bg.beginFill(0xffffff, 0.9);
            bg.drawRoundedRect(-w/2, -h/2, w, h, 8);
            bg.endFill();
            nodeMap.set(node.name, node);
        });

        data.edges.forEach(edgeData => {
            const from = nodeMap.get(edgeData.from);
            const to = nodeMap.get(edgeData.to);
            if (from && to) {
                createEdge(from, to);
                const edge = edges[edges.length - 1];
                edge.colorIndex = edgeData.colorIndex ?? 0;
                updateEdge(edge.graphic, from.pos, to.pos, colors[edge.colorIndex]);
                if (edgeData.text) {
                    updateEdgeLabel(edge, edgeData.text);
                }
            }
        });
    }

    function clearGraph() {
        nodes.forEach(n => {
            n.graphic.destroy();
            n.labelContainer.destroy();
        });
        edges.forEach(e => {
            e.graphic.destroy();
            if (e.labelContainer) e.labelContainer.destroy();
        });
        nodes = [];
        edges = [];
    }

    function onStageTap(e) {
        if (e.target !== app.stage) return;
        if (dbClickTimer) {
            clearTimeout(dbClickTimer);
            dbClickTimer = null;
            createNode(e.global);
        } else {
            dbClickTimer = setTimeout(() => { dbClickTimer = null; }, 250);
        }
    }

    function createNode(pos) {
        const name = getUnusedLetter();
        const graphic = new PIXI.Graphics()
            .circle(0, 0, 12)
            .fill({ color: 0xffffff });
        graphic.position.set(pos.x, pos.y);
        graphic.eventMode = 'static';
        graphic.cursor = 'pointer';
        graphic.on('pointerdown', onNodeDown);
        graphic.on('pointertap', onNodeTap);
        graphic.on('rightdown', e => { e.stopPropagation(); onNodeRight(e); });

        const label = new PIXI.Text({ text: name, style: textStyle });
        label.anchor.set(0.5);

        const paddingX = 7;
        const paddingY = 5;
        const bgWidth  = label.width  + paddingX * 2;
        const bgHeight = label.height + paddingY * 2;

        const bg = new PIXI.Graphics();
        bg.beginFill(0xffffff, 0.9);
        bg.drawRoundedRect(-bgWidth/2, -bgHeight/2, bgWidth, bgHeight, 8);
        bg.endFill();

        const labelContainer = new PIXI.Container();
        labelContainer.addChild(bg, label);
        label.position.set(0,0);
        labelContainer.position.set(pos.x + 16 + bgWidth/2, pos.y);

        app.stage.addChild(graphic, labelContainer);

        const node = { graphic, labelContainer, name, pos: {x:pos.x, y:pos.y}, colorIndex: 0 };
        nodes.push(node);
        graphic.nodeRef = node;
    }

    function getUnusedLetter() {
        const used = new Set(nodes.map(n => n.name));
        for (let i = 0; i < 26; i++) {
            const char = String.fromCharCode(65 + i);
            if (!used.has(char)) return char;
        }
        return String.fromCharCode(65 + (nodes.length % 26));
    }

    function onNodeTap(e) {
        e.stopPropagation();
        const node = e.target.nodeRef;
        node.colorIndex = (node.colorIndex + 1) % colors.length;
        updateNodeColor(node);
    }

    function updateNodeColor(node) {
        node.graphic.clear()
            .circle(0, 0, 12)
            .fill({ color: colors[node.colorIndex] });
    }

    function onNodeDown(e) {
        e.stopPropagation();
        draggingNode = e.target.nodeRef;
        tempLine = new PIXI.Graphics();
        app.stage.addChild(tempLine);

        app.canvas.addEventListener('pointermove', onDragMoveGlobal);
        app.canvas.addEventListener('pointerup', onDragEndGlobal);
        app.canvas.addEventListener('pointerupoutside', onDragEndGlobal);

        if (e.target.setPointerCapture) {
            e.target.setPointerCapture(e.pointerId);
        }
    }

    function onDragMoveGlobal(e) {
        if (!draggingNode || !tempLine) return;
        const rect = app.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        tempLine.clear()
            .moveTo(draggingNode.pos.x, draggingNode.pos.y)
            .lineTo(x, y)
            .stroke({ width: 3, color: 0xffffff });
    }

    function onDragEndGlobal(e) {
        app.canvas.removeEventListener('pointermove', onDragMoveGlobal);
        app.canvas.removeEventListener('pointerup', onDragEndGlobal);
        app.canvas.removeEventListener('pointerupoutside', onDragEndGlobal);

        if (tempLine) {
            tempLine.destroy();
            tempLine = null;
        }

        if (draggingNode) {
            const rect = app.canvas.getBoundingClientRect();
            const px = e.clientX - rect.left;
            const py = e.clientY - rect.top;

            let targetNode = null;
            for (let node of nodes) {
                if (node === draggingNode) continue;
                const dx = px - node.pos.x;
                const dy = py - node.pos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist <= 15) {
                    targetNode = node;
                    break;
                }
            }

            if (targetNode && !edgeExists(draggingNode, targetNode)) {
                createEdge(draggingNode, targetNode);
            }
        }

        draggingNode = null;
    }

    function edgeExists(a, b) {
        return edges.some(edge =>
            (edge.from === a && edge.to === b) || (edge.from === b && edge.to === a)
        );
    }

    function createEdge(from, to) {
        const graphic = new PIXI.Graphics();
        updateEdge(graphic, from.pos, to.pos, 0xffffff);
        graphic.eventMode = 'static';
        graphic.cursor = 'pointer';
        graphic.on('pointerdown', onEdgeDown);
        graphic.on('pointerup', onEdgeUp);
        graphic.on('pointertap', onEdgeTap);
        graphic.on('rightdown', e => { e.stopPropagation(); onEdgeRight(e); });
        edgeContainer.addChild(graphic);

        const edge = { graphic, from, to, colorIndex: 0, labelContainer: null, text: '' };
        edges.push(edge);
        graphic.edgeRef = edge;
    }

    function updateEdge(graphic, fromPos, toPos, color) {
        graphic.clear()
            .moveTo(fromPos.x, fromPos.y)
            .lineTo(toPos.x, toPos.y)
            .stroke({ width: 4, color });
    }

    function onEdgeTap(e) {
        e.stopPropagation();
        const edge = e.target.edgeRef;
        edge.colorIndex = (edge.colorIndex + 1) % colors.length;
        updateEdge(edge.graphic, edge.from.pos, edge.to.pos, colors[edge.colorIndex]);
        if (edge.labelContainer) updateEdgeLabelPosition(edge);
    }

    function onNodeRight(e) {
        const node = e.target.nodeRef;
        if (!node) return;
        
        edges = edges.filter(edge => {
            if (edge.from === node || edge.to === node) {
                if (edge.labelContainer) {
                    edge.labelContainer.destroy();
                    edge.labelContainer = null;
                }
                edge.graphic.destroy();
                return false;
            }
            return true;
        });
        
        node.graphic.destroy();
        node.labelContainer.destroy();
        nodes = nodes.filter(n => n !== node);
    }

    function onEdgeRight(e) {
        const edge = e.target.edgeRef;
        if (!edge) return;
        
        if (longPressTarget === edge) {
            clearTimeout(longPressTimer);
            longPressTarget = null;
        }
        
        if (edge.labelContainer) {
            edge.labelContainer.destroy();
            edge.labelContainer = null;
        }
        
        edge.graphic.destroy();
        edges = edges.filter(ed => ed !== edge);
    }

    function onEdgeDown(e) {
        if (e.button !== 0) return;
        
        e.stopPropagation();
        longPressTarget = e.target.edgeRef;
        longPressTimer = setTimeout(() => {
            if (longPressTarget) showEdgeLabelInput(longPressTarget, e.global);
        }, 500);
    }

    function onEdgeUp(e) {
        if (e.button !== 0) return;
        clearTimeout(longPressTimer);
        longPressTarget = null;
    }

    function showEdgeLabelInput(edge, pos) {
        const input = document.createElement('input');
        input.type = 'text';
        input.value = edge.text;
        input.style.position = 'absolute';
        input.style.left = `${pos.x}px`;
        input.style.top = `${pos.y}px`;
        input.style.zIndex = '1000';
        document.body.appendChild(input);
        input.focus();

        input.addEventListener('blur', () => {
            updateEdgeLabel(edge, input.value);
            document.body.removeChild(input);
        });

        input.addEventListener('keydown', (ev) => {
            if (ev.key === 'Enter') input.blur();
        });
    }

    function updateEdgeLabel(edge, text) {
        edge.text = text;
        if (edge.labelContainer) edge.labelContainer.destroy();

        if (!text) {
            edge.labelContainer = null;
            return;
        }

        const label = new PIXI.Text({ text, style: textStyle });
        label.anchor.set(0.5, 0.5);

        const paddingX = 6;
        const paddingY = 5;
        const bgWidth = label.width + paddingX * 2;
        const bgHeight = label.height + paddingY * 2;

        const bg = new PIXI.Graphics();
        bg.beginFill(0xffffff, 0.92);
        bg.drawRoundedRect(
            -bgWidth / 2,
            -bgHeight / 2,
            bgWidth,
            bgHeight,
            6
        );
        bg.endFill();

        const labelContainer = new PIXI.Container();
        labelContainer.addChild(bg);
        labelContainer.addChild(label);
        label.position.set(0, 0);

        updateEdgeLabelPosition(edge, labelContainer);
        app.stage.addChild(labelContainer);
        edge.labelContainer = labelContainer;
    }

    function updateEdgeLabelPosition(edge, container = edge.labelContainer) {
        if (!container) return;
        const midX = (edge.from.pos.x + edge.to.pos.x) / 2;
        const midY = (edge.from.pos.y + edge.to.pos.y) / 2;
        container.position.set(midX, midY);
    }

    window.addEventListener('resize', () => app.resize());
})();
</script>
</body>
</html>